МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 


Кафедра «Програмна інженерія»
 



ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу коду програмного забезпечення»
 



 
Виконала:                                                           	              	Прийняв:
ст. гр. ПЗПІ-22-7                                    	       	     		Сокорчук І.П.
Кравченко В. А.







Харків 2024
     Мета заняття:
     Навчити студентів основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Студенти повинні навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.
     Завдання:
1. Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2. Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
3. Кожен метод рефакторингу повинен супроводжуватись:
• Описом проблеми, яку вирішує даний метод.
• Кодом до і після застосування методу рефакторингу.
• Поясненням переваг використаного методу.
     Хід роботи:
     Рефакторинг — це процес вдосконалення існуючого коду без зміни його зовнішньої функціональності. Мета рефакторингу полягає в підвищенні якості програмного забезпечення, що включає поліпшення читабельності, структури, підтримуваності та ефективності коду. 
     
     Основні аспекти рефакторингу включають:
     1. Рефакторинг робить код більш зрозумілим для інших розробників, що полегшує його читання та розуміння. Це може бути досягнуто шляхом використання більш зрозумілих імен змінних, спрощення складних виразів або розбиття великих функцій на менші.
     2. Рефакторинг дозволяє уникати повторення одного і того ж коду, що спрощує підтримку та оновлення програмного забезпечення. Використання функцій, класів або інших структур для повторного використання коду підвищує його ефективність.
     3. За допомогою рефакторингу можна створити більш логічну та організовану структуру проекту. Це включає впровадження шаблонів проектування, модульність та розподіл відповідальності між класами та методами.
     4. Рефакторинг може також включати оптимізацію коду, що призводить до підвищення його швидкості та зменшення споживання ресурсів.
     5. Чистий і добре структурований код легше підтримувати та модифікувати. Це знижує ймовірність виникнення помилок і полегшує внесення змін у майбутньому.
     Рефакторинг є невід’ємною частиною життєвого циклу програмного забезпечення, оскільки він дозволяє зберігати код у актуальному стані, що відповідає сучасним стандартам якості та найкращим практикам.
     
     1)Метод Replace Temp with Query (Замінити Тимчасову Змінну Запитом) є підходом для покращення читабельності та підтримуваності коду шляхом заміни тимчасових змінних, які зберігають значення, отримані з обчислень, на спеціальні методи-запити (гетери). Це допомагає уникнути зберігання складних або проміжних обчислень у змінних та створює більш гнучкий і зручний код.
     
     Проблеми з використанням тимчасових змінних:
     1. Обмеженість застосування значення: коли змінна зберігає обчислене значення, воно доступне лише в межах поточної області (наприклад, в методі). Якщо це значення потрібно деінде, обчислення потрібно повторити.
     2. Проблеми з повторним використанням логіки: якщо обчислення значення є складним, будь-яка зміна в логіці потребує перегляду та зміни кожного місця, де використовується змінна.
     3. Вплив на зрозумілість коду: тимчасові змінні можуть ускладнювати розуміння коду, особливо якщо назви змінних не є інформативними або обчислення є довгим і нелогічним для подальшого аналізу.

     Переваги методу Replace Temp with Query:
     1. Централізація логіки: вся логіка обчислення переміщується в один метод, що дозволяє її легко знайти, змінити та використовувати.
     2. Гнучкість і розширюваність: замість дублювання коду, ми викликаємо метод, який повертає результат, тому будь-які зміни в логіці потребують правки лише в одному місці.
     3. Поліпшення зрозумілості: метод-запит часто має інформативну назву, що допомагає зрозуміти, що обчислюється, без глибокого занурення в код.
     
     Приклад коду на мові програмування C#
     Код до рефакторингу:
     Розглянемо клас для розрахунку суми замовлення зі знижкою. У початковій версії тимчасова змінна discount зберігає обчислення знижки.
public class Order
{
    private decimal basePrice;
    private decimal discountRate;
    private int quantity;

    public Order(decimal basePrice, decimal discountRate, int quantity)
    {
        this.basePrice = basePrice;
        this.discountRate = discountRate;
        this.quantity = quantity;
    }

    public decimal CalculateTotalPrice()
    {
        decimal baseTotal = basePrice * quantity;
        decimal discount = 0;

        if (quantity > 100)
        {
            discount = baseTotal * discountRate;
        }

        return baseTotal - discount;
    }
}

     Проблеми початкового коду:
     • Тимчасова змінна discount: використовується для зберігання проміжного значення, що ускладнює розуміння коду, оскільки основна логіка розрахунку розбита на дві частини (визначення discount та її використання в return).
     • Можливість помилок при розширенні: зміни в логіці знижок потребуватимуть змін саме в цій ділянці коду, що робить підтримку і тестування складнішими.
     • Обмежений доступ до обчислень: значення discount доступне тільки в методі CalculateTotalPrice. Якщо необхідно використовувати логіку розрахунку знижки в іншому методі або класі, потрібно повторно дублювати обчислення.
     • Складність читання: користувачам класу буде важко зрозуміти, як саме обчислюється discount, якщо логіка зміниться.
     
     Код після рефакторингу:
     Застосуємо метод Replace Temp with Query, створивши методи-запити GetBaseTotal і GetDiscount, які повертатимуть необхідні обчислення.
public class Order
{
    private decimal basePrice;
    private decimal discountRate;
    private int quantity;

    public Order(decimal basePrice, decimal discountRate, int quantity)
    {
        this.basePrice = basePrice;
        this.discountRate = discountRate;
        this.quantity = quantity;
    }

    private decimal GetBaseTotal()
    {
        return basePrice * quantity;
    }

    private decimal GetDiscount()
    {
        return quantity > 100 ? GetBaseTotal() * discountRate : 0;
    }

    public decimal CalculateTotalPrice()
    {
        return GetBaseTotal() - GetDiscount();
    }
}

     Метод Replace Temp with Query є оптимальним, тому що:
     • Він дозволяє перемістити обчислення discount у метод-запит, що видаляє необхідність використовувати тимчасову змінну і централізує логіку.
     • Перенесення логіки знижки у метод GetDiscount робить код більш модульним і гнучким, оскільки метод CalculateTotalPrice тепер викликає інший метод, що повертає результат, а не використовує проміжне значення.
     • Усі зміни, пов'язані зі знижкою, тепер виконуються тільки в методі GetDiscount, що значно спрощує підтримку.

     Після рефакторингу код став зрозумілішим і підтримуванішим:
     • Покращена читабельність: метод CalculateTotalPrice тепер виглядає простіше, оскільки обчислення винесені в окремий метод GetDiscount. Тепер зрозуміло, що підсумкова ціна розраховується як різниця між базовою ціною і знижкою.
     • Логічна структура: метод GetDiscount забезпечує чітке відокремлення логіки знижки, що робить код більш структурованим і зрозумілим.
     • Гнучкість: завдяки методу GetDiscount можна легко додати нові умови для обчислення знижки, не змінюючи метод CalculateTotalPrice.

     2) Метод Consolidate Conditional Expression (Об’єднання умовних виразів).
     Consolidate Conditional Expression — це метод рефакторингу, що використовується для спрощення складної умовної логіки шляхом об'єднання кількох умовних виразів в одну умову. Цей метод має на меті зробити код більш зрозумілим, компактним і легким для підтримки.
     
     Що робить Consolidate Conditional Expression?
Consolidate Conditional Expression об'єднує кілька умов, які мають однаковий або подібний результат, у єдиний умовний вираз. Замість того щоб перевіряти кілька умов в окремих блоках if або else if, цей метод дозволяє скоротити код за допомогою одного виразу, що перевіряє всі необхідні умови одночасно.

     Коли застосовувати цей метод?
     1. Кілька умов виконують однакову дію: якщо кілька умов призводять до однакового результату або викликають однаковий код, має сенс об'єднати їх в один умовний вираз.
     2. Покращення логіки: якщо умови мають логічно пов'язану природу (наприклад, всі вони описують, чи отримає користувач знижку), метод дозволяє показати цю логіку чіткіше.
     3. Зменшення дублювання: об’єднання умов допомагає уникнути дублювання коду, що сприяє покращенню читабельності та полегшенню підтримки.
     
     Можливі проблеми початкової версії коду:
     1. Розкиданість логіки: коли логіка розподілена по кількох умовних блоках, важко побачити, що всі вони призводять до одного результату. Це створює враження, ніби кожна умова виконує щось особливе, хоча вони всі приводять до однієї дії.
     2. Складність підтримки: якщо потрібно змінити дію, яку виконує кожна умова, це означає змінювати її у кількох місцях, що підвищує ризик помилок і ускладнює підтримку коду.
     3. Збільшення кількості умов: додавання нових умов до кожного блоку if або else if призводить до значного ускладнення коду, що робить його складнішим для розширення та розуміння.

     Як ці проблеми впливають на читабельність, підтримку або розширення коду?
     • Читабельність: розкиданість умовного коду ускладнює розуміння логіки визначення знижки. Виникає враження, що кожна умова має різний результат, що робить код заплутаним і менш зрозумілим для майбутніх розробників.
     • Підтримка: якщо бізнес-логіка знижок зміниться, потрібно буде оновлювати кілька блоків коду. Це робить процес підтримки трудомістким і підвищує ризик появи помилок.
     • Розширення: додавання нових умов для знижки потребуватиме нових if-блоків, що додатково ускладнюватиме код і може призвести до повторення тих самих помилок.
     
     Приклад коду до рефакторингу:
public class Order
{
    private decimal orderValue;
    private bool isPriorityCustomer;
    private int customerYears;

    public Order(decimal orderValue, bool isPriorityCustomer, int customerYears)
    {
        this.orderValue = orderValue;
        this.isPriorityCustomer = isPriorityCustomer;
        this.customerYears = customerYears;
    }

    public decimal CalculateDiscount()
    {
        decimal discount = 0;

        if (orderValue > 1000)
        {
            discount = 0.05m;
        }

        if (isPriorityCustomer)
        {
            discount = 0.05m;
        }

        if (customerYears > 5)
        {
            discount = 0.05m;
        }

        return orderValue * (1 - discount);
    }
       }	
     
     Опис проблеми в початковому коді:
     • Зайве дублювання логіки: кожна умова, яка призводить до надання знижки, визначає змінну discount у різних блоках if, попри те, що результат завжди той самий (0.05). Це створює непотрібне дублювання коду.
     • Ускладненість для розуміння логіки: кожен умовний блок виглядає так, ніби має власне значення, хоча всі вони призводять до однакового результату. Це може вводити в оману при перегляді коду і ускладнювати розуміння логіки знижки.
     • Підвищений ризик помилок: якщо потрібно змінити значення discount, програмісту доведеться змінювати його у кожному умовному блоці. Це підвищує ймовірність залишити один із блоків незміненим, що може призвести до непослідовностей.

     Рефакторинг за допомогою Consolidate Conditional Expression:
Ми можемо об'єднати всі умови в один вираз, який перевірятиме всі три критерії одразу.
public class Order
{
    private decimal orderValue;
    private bool isPriorityCustomer;
    private int customerYears;

    public Order(decimal orderValue, bool isPriorityCustomer, int customerYears)
    {
        this.orderValue = orderValue;
        this.isPriorityCustomer = isPriorityCustomer;
        this.customerYears = customerYears;
    }

    public decimal CalculateDiscount()
    {
        decimal discount = (orderValue > 1000 || isPriorityCustomer || customerYears > 5) ? 0.05m : 0;
        return orderValue * (1 - discount);
    }
}

     Пояснення покращень після рефакторингу:
     • Покращена читабельність: усі умови, які визначають знижку, зведені до одного рядка, що чітко демонструє логіку знижки і полегшує розуміння коду.
     • Полегшена підтримка: тепер для зміни значення discount досить внести зміни лише в одному місці.
     • Зменшення дублювання: метод уникнув дублювання коду, бо тепер усі умови об’єднані в одному виразі.
     
     Технічні переваги:
     • Зменшення дублювання: скорочення кількості умов зменшує кількість рядків коду, що робить його менш громіздким.
     • Покращена структура: консолідація умов дозволяє швидко визначити, які умови використовуються для знижки, що покращує структуру і читабельність.
     • Зручність у тестуванні: зведення умов до одного виразу полегшує перевірку результатів тестування, що зменшує кількість необхідних тестових сценаріїв.
     
     Чому обраний метод рефакторингу є оптимальним для вирішення цієї проблеми?
     Consolidate Conditional Expression є оптимальним методом для вирішення цієї проблеми, оскільки він дозволяє об'єднати всі умови в один вираз. Це допомагає уникнути дублювання, полегшує внесення змін та робить логіку обчислення знижки зрозумілішою. Тепер усі умови знаходяться в одному місці, що полегшує підтримку, оскільки для оновлення бізнес-логіки достатньо змінити лише один рядок.
     
     Як рефакторинг зробив код більш читабельним та підтримуваним?
     • Читабельність: після рефакторингу логіка надання знижки зведена до одного рядка, що робить код лаконічним і зрозумілим. Зараз чітко видно, що знижка надається, якщо виконується хоча б одна з трьох умов, а значення знижки — 0.05.
     • Підтримка: оскільки вся логіка знижки сконцентрована в одному рядку, оновлення бізнес-логіки стає простішим. Тепер розробник може змінити значення discount або умови для його призначення лише в одному місці, що знижує ймовірність помилок і спрощує підтримку.

	3) Метод Encapsulate Collection
     Метод Encapsulate Collection (інкапсуляція колекції) є одним із ключових прийомів рефакторингу, який дозволяє контролювати доступ до колекцій (наприклад, списків, масивів або словників) в об'єктно-орієнтованому програмуванні. Цей метод зосереджений на створенні абстракцій навколо колекцій, щоб обмежити безпосередній доступ до їхніх даних, надаючи чіткіший і безпечніший спосіб маніпулювати цими даними.
     
     Основна ідея методу:
     Основна ідея цього методу полягає в тому, щоб захистити внутрішнє представлення даних класу від зовнішнього світу, надаючи лише обмежений доступ до колекції через специфічні методи. Це дозволяє розробникам:
     1. Контролювати доступ: зменшити ризик внесення помилок через ненавмисні зміни в колекції.
     2. Управляти змінами: зробити зміни в способі зберігання чи обробки даних без впливу на код, який взаємодіє з цим класом.
     3. Підвищити читабельність: створити більш зрозумілий інтерфейс для користувачів класу, вказуючи на те, як дані можуть бути модифіковані або отримані.
Код до рефакторингу:
using System;
using System.Collections.Generic;

public class ShoppingCart
{
    public List<string> Items { get; private set; }

    public ShoppingCart()
    {
        Items = new List<string>();
    }

    public void AddItem(string item)
    {
        Items.Add(item);
    }

    public void RemoveItem(string item)
    {
        Items.Remove(item);
    }

    public void PrintItems()
    {
        foreach (var item in Items)
        {
            Console.WriteLine(item);
        }
    }
}
     Проблеми у початковій версії коду:
     1. Безпосередній доступ до колекції:
     У класі ShoppingCart властивість Items є публічною, що дозволяє зовнішньому коду отримувати доступ до колекції і змінювати її безпосередньо. Це може призвести до небажаних змін у колекції, наприклад, випадкового видалення або модифікації елементів.
     2. Відсутність контролю даних:
     Методи AddItem та RemoveItem не перевіряють, чи не є доданий елемент порожнім або null. Це може призвести до ситуацій, коли у колекції з'являються некоректні дані, що ускладнить подальшу обробку.
     3. Вразливість до помилок:
     Якщо зовнішній код намагається видалити елемент, який не існує в списку, метод RemoveItem просто нічого не робить, що може бути неочікуваним для розробника. Крім того, немає жодних повідомлень про помилки або валідацію, що може ускладнити виявлення помилок.
     4. Обмежена функціональність:
     Клас ShoppingCart має лише базову функціональність. Наприклад, немає можливості перевіряти, чи містить колекція певний елемент, або отримувати кількість елементів, що можуть бути важливими для користувача.
     
     Як ці проблеми впливають на читабельність, підтримку або розширення коду:
     • Читабельність: код стає менш зрозумілим, оскільки важко визначити, які частини програми можуть змінювати колекцію. Це ускладнює розуміння того, як клас ShoppingCart працює, і які наслідки можуть мати зміни в Items.
     • Підтримка: оскільки колекція може бути змінена з різних місць програми, це ускладнює виявлення джерела помилок. Якщо структура колекції або її поведінка змінюється, доведеться перевіряти багато місць коду, що потребує більше часу та зусиль.
     • Розширення: додавання нових функцій або зміна способу зберігання даних може стати складнішим завданням через ненадійний доступ до колекції. Якщо потрібно буде змінити структуру даних, це вимагатиме значних зусиль.

     Які проблеми виникають при збереженні початкової версії коду?
• Безпосередній доступ до колекції: у початковій версії коду, колекція Items є публічною, що дозволяє зовнішнім класам змінювати її безпосередньо. Це може призвести до небажаних змін у колекції.
• Відсутність контролю даних: методи AddItem і RemoveItem не мають жодних перевірок, що дозволяє додавати некоректні або пусті значення, а також видаляти елементи, які не існують.
• Вразливість до помилок: ненавмисні зміни, зроблені в Items, можуть призвести до помилок, які важко відстежити. Наприклад, якщо хтось видалить елемент без належного контролю, це може призвести до непередбачуваних результатів при розрахунках.

     Код після рефакторингу:
     
using System;
using System.Collections.Generic;

public class ShoppingCart
{
    private List<string> items;  // Змінена видимість колекції на приватну

    public ShoppingCart()
    {
        items = new List<string>();
    }

    public void AddItem(string item)
    {
        if (string.IsNullOrEmpty(item))
        {
            Console.WriteLine("Item cannot be null or empty.");
            return;
        }
        items.Add(item);
    }

    public void RemoveItem(string item)
    {
        if (items.Remove(item))
        {
            Console.WriteLine($"{item} was removed from the cart.");
        }
        else
        {
            Console.WriteLine($"{item} not found in the cart.");
        }
    }

    public void PrintItems()
    {
        if (items.Count == 0)
        {
            Console.WriteLine("The cart is empty.");
            return;
        }

        Console.WriteLine("Items in the cart:");
        foreach (var item in items)
        {
            Console.WriteLine(item);
        }
    }

    public bool ContainsItem(string item)
    {
        return items.Contains(item);
    }

    public int GetItemCount()
    {
        return items.Count;
    }
}
     Опис змін:
     • Захищена колекція: приватне поле items забезпечує захист від зовнішніх змін, що зменшує ризик помилок.
     • Валідація даних: додані перевірки в методах AddItem і RemoveItem підвищують безпеку класу та зменшують ймовірність помилок.
     • Розширена функціональність: методи ContainsItem і GetItemCount дозволяють користувачам отримувати більше інформації про стан колекції без потреби в прямому доступі до неї.
     • Читабельність та підтримка: чітке визначення інтерфейсів і контроль доступу до колекції роблять клас більш зрозумілим і легшим для підтримки.
     Пояснення покращень після рефакторингу:
     Як рефакторинг зробив код більш читабельним та підтримуваним?
     • Підвищення читабельності: завдяки приватному доступу до колекції та чітким методам доступу, інші розробники можуть швидше зрозуміти, як працює клас ShoppingCart, і як саме можна модифікувати його дані.
     • Зменшення ризику помилок: введення перевірок на допустимість значень і наявність елементів зменшує ймовірність помилок, які можуть виникати при додаванні чи видаленні даних.
     • Простота обслуговування: у разі зміни вимог до даних (наприклад, потрібно буде змінити тип колекції або логіку зберігання), розробнику знадобиться змінити тільки код у класі ShoppingCart, не торкаючись інших частин програми, що значно полегшує обслуговування та розвиток.

     Як метод Encapsulate Collection вирішує проблеми:
     1. Захист колекції:
     Замість того, щоб надавати публічний доступ до колекції Items, можна зробити цю властивість приватною. Це забезпечить контроль над тим, як можна взаємодіяти з колекцією.
     2. Створення чітких інтерфейсів:
     Додавши методи для маніпуляції з колекцією, такі як AddItem, RemoveItem і GetItems, можна визначити чіткі правила для взаємодії з даними. Наприклад, метод AddItem може перевіряти, чи є item порожнім або null, перш ніж додати його до колекції.
     3. Валідація даних:
     Можливість додавання логіки в методи для перевірки наявності елементів або виведення повідомлень про помилки підвищує безпеку та передбачуваність класу. Наприклад, можна виводити повідомлення, якщо намагаються видалити елемент, якого немає у колекції.
     4. Розширення функціональності:
     Запровадження нових методів для перевірки стану колекції, таких як ContainsItem, GetItemCount, дасть можливість легко розширювати функціональність класу без внесення змін у зовнішній код, що використовує цей клас.

     Які технічні переваги забезпечує цей метод?
     1. Зменшення ризику помилок: обмеження доступу до колекції зменшує ймовірність внесення помилок, які можуть виникнути при ненавмисному зміненні стану колекції з зовнішніх класів.
     2. Краща структура: визначення чітких методів для маніпуляції з колекцією робить код легшим для розуміння і використання, дозволяючи розробникам краще організовувати логіку програми.
     3. Гнучкість: у майбутньому, якщо потрібно буде змінити тип колекції або спосіб доступу до даних, це можна зробити, не впливаючи на код, який використовує клас ShoppingCart. Це значно полегшує розширення і модифікацію програми.

     Чому обраний метод рефакторингу є оптимальним для вирішення цієї проблеми?
     Метод Encapsulate Collection є оптимальним для вирішення цих проблем, оскільки:
     • Контролює доступ: захищаючи колекцію, цей метод забезпечує контроль над доступом до даних, що зменшує ризик внесення помилок.
     • Визначає чіткі інтерфейси: створення специфічних методів для маніпуляції з колекцією (додавання, видалення, отримання) робить код зрозумілішим для тих, хто його використовує.
     • Сприяє гнучкості: зміна способу реалізації колекції може бути виконана в одному місці (всередині класу ShoppingCart) без впливу на зовнішній код, що спрощує подальші модифікації та розширення.

     Висновок:
     Методи рефакторингу, такі як Replace Temp with Query, Consolidate Conditional Expression, і Encapsulate Collection, є важливими інструментами для покращення якості коду. Вони допомагають усунути проблеми, які виникають у результаті складної логіки, дублювання коду та недостатнього контролю над даними. 
     1. Replace Temp with Query: цей метод зменшує використання тимчасових змінних, що підвищує читабельність та зрозумілість коду. Він дозволяє уникнути помилок, пов'язаних із неправильним використанням значень, зберігаючи логіку програми простішою і зрозумілішою.
     2. Consolidate Conditional Expression: використання цього методу дозволяє спростити умовні вирази, зменшуючи їхню складність і підвищуючи читабельність. Це також зменшує ймовірність помилок, адже в результаті з’являється менше дублювання коду і краща структурованість умовної логіки.
     3. Encapsulate Collection: цей метод забезпечує контроль над доступом до колекцій, дозволяючи зменшити ризики випадкових змін даних. Завдяки обмеженню прямого доступу до колекцій, код стає більш безпечним і підтримуваним, адже всі маніпуляції з даними проходять через чітко визначені інтерфейси.
     Усі ці методи спільно підвищують якість коду, роблять його легшим для читання, підтримки та розширення. Використання рефакторингу в програмуванні — це ключовий аспект, що сприяє створенню більш надійних і зрозумілих програмних систем.
     Посилання на відеозапис доповіді Refactoring Methods на YouTube: https://youtu.be/01ui-G_JHJo
     Додаток:

     Рисунок 1 – слайд презентації №1

     Рисунок 2 – слайд презентації №2


     Рисунок 3 – слайд презентації №3

     Рисунок 4 – слайд презентації №4


     Рисунок 5 – слайд презентації №5


     Рисунок 6 – слайд презентації №6


     Рисунок 7 – слайд презентації №7


     Рисунок 8 – слайд презентації №8


     Рисунок 9 – слайд презентації №9


     Рисунок 10 – слайд презентації №10


     Рисунок 11 – слайд презентації №11


     Рисунок 12 – слайд презентації №12


     Рисунок 13 – слайд презентації №13


     Рисунок 14 – слайд презентації №14


     Рисунок 15 – слайд презентації №15

