МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 


Кафедра «Програмна інженерія»
 



ЗВІТ
з лабораторної роботи №3
з дисципліни «Аналіз та рефакторинг коду»
на тему «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»
 



 
Виконала:                                                           	              	Прийняв:
ст. гр. ПЗПІ-22-7                                    	       	     		Сокорчук І.П.
Кравченко В. А.





Харків 2024
     На лабораторній роботі №3 потрібно розробити бізнес-логику та функції адміністрування серверної частини  програмної системи. 
     Створення UML-діаграми діяльності для серверної частини проєкту AquaTrack потребує детального опису процесів, які система виконує для роботи з даними про водоспоживання. Розглянемо процес отримання історії водоспоживання з фільтрацією за пристроєм і періодом.
     Кроки для створення UML-діаграми діяльності:
     Діаграма діяльності складається з елементів, що відображають основні етапи виконання завдань: початкові/кінцеві точки, дії, рішення, потоки і об'єкти.
     Опис дій для серверної частини включає:
     1. Прийняття HTTP-запиту клієнта.
     2. Передача запиту в контролер.
     3. Виконання бізнес-логіки (сервіс).
     4. Звернення до бази даних через репозиторій.
     5. Обробка даних і повернення відповіді клієнту.
     Основний процес:
     1. Прийом HTTP-запиту:
     • Користувач через клієнт (наприклад, веб-додаток) надсилає запит до API.
     • Запит може містити параметри deviceId, startDate, endDate для фільтрації.
     2. Обробка у контролері:
     • Контролер отримує параметри із запиту.
     • Передає параметри в сервіс для виконання бізнес-логіки.
     3. Виконання бізнес-логіки:
     • Сервіс виконує перевірку параметрів (наприклад, чи всі поля заповнені).
     • Формує фільтри для пошуку в базі даних.
     4. Отримання даних з бази даних через репозиторій:
     • Сервіс передає сформовані фільтри в репозиторій.
     • Репозиторій звертається до бази даних і виконує запит для отримання відповідних записів.
     5. Обробка результатів і повернення:
     • Сервіс обробляє отримані дані (наприклад, сортує за датою).
     • Повертає їх у контролер.
     • Контролер формує HTTP-відповідь і відправляє клієнту.
     Елементи для UML-діаграми діяльності:
     1. Початок процесу:
     • Початкова точка.
     2. Дії:
     • Користувач надсилає запит.
     • Контролер отримує і перевіряє запит.
     • Сервіс обробляє параметри.
     • Репозиторій виконує запит до бази даних.
     • Сервіс обробляє дані.
     • Контролер формує відповідь.
     3. Рішення:
     • Перевірка, чи запит містить необхідні параметри.
     • Перевірка, чи знайдено записи у базі даних.
     4. Потоки:
     • Потік між користувачем і сервером.
     • Потік між контролером, сервісом і репозиторієм.
     5. Кінцеві точки:
     • Успішне повернення результатів.
     • Повернення помилки (наприклад, якщо даних не знайдено).
     Текстовий опис процесу для UML:
     1. Початкова точка → Користувач надсилає HTTP-запит (/api/water-usage/history) з параметрами deviceId, startDate, endDate.
     2. Дія: контролер отримує запит і передає параметри в сервіс.
     3. Рішення: перевірка, чи параметри заповнені. 
     • Якщо ні: відправити відповідь «400 Bad Request».
     • Якщо так: продовжити.
     4. Дія: сервіс формує фільтри.
     5. Дія: репозиторій виконує запит до бази даних.
     6. Рішення: чи знайдено записи? 
     • Якщо ні: відправити відповідь «404 Not Found».
     • Якщо так: продовжити.
     7. Дія: сервіс обробляє дані (сортує, додає додаткові поля).
     8. Дія: контролер формує HTTP-відповідь.
     9. Кінцева точка: відправка відповіді клієнту.

Рисунок 1 – UML діаграма діяльності для серверної частини.

     UML Діаграма Взаємодії для Серверної Частини AquaTrack:
     Діаграма взаємодії показує, як об'єкти та компоненти серверної частини взаємодіють між собою для виконання певної задачі. Детальний опис, як це виглядатиме для функціоналу «Перегляд історії водоспоживання»:
     Основні Об’єкти (учасники взаємодії):
     1. Клієнт: веб-додаток або мобільний застосунок, який надсилає HTTP-запит.
     2. Контролер (WaterUsageController): приймає запит від клієнта та викликає відповідний сервіс.
     3. Сервіс (WaterUsageService): виконує бізнес-логіку, такі як фільтрація даних, перевірка параметрів тощо.
     4. Репозиторій (WaterUsageRepository): отримує дані з бази даних.
     5. База даних (Database): містить таблиці, такі як WaterUsages.
     Опис взаємодії:
     1. Клієнт відправляє запит:
     • Клієнт надсилає HTTP GET запит на api/water-usage/history для отримання історії водоспоживання.
     • Дані у запиті: параметри: deviceId, startDate, endDate (можливо, необов'язкові).
     2. Контролер отримує запит:
     • WaterUsageController викликає метод GetHistory() у WaterUsageService.
     • Передає параметри (якщо вони є) до сервісу.
     3. Сервіс обробляє дані:
     • WaterUsageService перевіряє передані параметри:
     o Якщо параметри відсутні, фільтрує всі записи за замовчуванням.
     o Якщо параметри присутні, створює фільтри для запиту до репозиторію.
     • Викликає метод GetAll() або спеціальний метод з умовами у WaterUsageRepository.
     4. Репозиторій звертається до бази даних:
     • WaterUsageRepository формує SQL-запит відповідно до отриманих фільтрів.
     • Надсилає запит до бази даних (таблиця WaterUsages).
     • Отримує результати (список записів про водоспоживання).
     5. Сервіс обробляє результати:
     • WaterUsageService отримує дані від репозиторію.
     • Сортує їх, форматує за потреби (наприклад, групує за датами або пристроями).
     • Повертає оброблений результат контролеру.
     6. Контролер формує відповідь:
     • WaterUsageController перетворює дані у формат JSON.
     • Повертає результат клієнту з відповідним HTTP статус-кодом.
     7. Клієнт отримує відповідь:
     • Клієнт отримує JSON-відповідь та відображає історію водоспоживання у вигляді графіків, таблиць тощо.

Рисунок 2 – UML діаграма взаємодії для серверної частини.

     Бізнес-логіка серверної частини програмної системи «AquaTrack» – це набір правил і процедур, які забезпечують виконання функціональних вимог програми. В контексті проєкту AquaTrack бізнес-логіка повинна включати:
     Управління користувачами:
     1. Реєстрація користувачів:
     • Перевірка, чи не існує користувач із таким же email.
     • Збереження хешованого пароля для безпеки.
     • Призначення ролі за замовчуванням («User»).
     2. Авторизація користувачів:
     • Валідація введених даних (email та пароль).
     • Порівняння хешованого пароля з тим, що зберігається в базі даних.
     3. Управління профілем:
     • Зміна пароля.
     • Перевірка валідності змін (наприклад, унікальність email).
     4. Адміністративні функції
     • Видалення користувачів.
     • Перегляд списку користувачів.
     Управління IoT-пристроями:
     1. Додавання нового пристрою:
     • Перевірка, чи пристрій із таким номером вже існує.
     2. Збір даних від пристроїв:
     • Обробка отриманих даних (наприклад, обсяг використаної води).
     • Збереження даних у базу з прив'язкою до пристрою.
     3. Моніторинг стану пристроїв:
     • Генерація сповіщень.
     
     Управління лімітами водоспоживання:
     1. Створення лімітів:
     • Призначення максимального обсягу використаної води для певного періоду (наприклад, день, місяць).
     • Прив'язка ліміту до конкретного пристрою, користувача.
     2. Перевірка перевищення лімітів:
     • Розрахунок поточного обсягу використаної води.
     • Генерація сповіщень у разі перевищення.
     3. Статистика по лімітах:
     • Показник, наскільки використання води наближається до ліміту.
     Управління даними про використання води:
     1. Збереження даних:
     • Прийом даних про обсяг використаної води від IoT-пристроїв.
     • Прив'язка цих даних до пристрою.
     2. Аналіз даних:
     • Підрахунок середнього обсягу водоспоживання за день, місяць тощо.
     • Візуалізація статистики для клієнта.
     3. Генерація звітів:
     • Формування звітів по використанню води для адміністратора чи користувача.
     Валідація та обробка помилок:
     1. Валідація вхідних даних:
     • Перевірка наявності всіх обов’язкових полів.
     • Перевірка форматів (наприклад, email, числові значення).
     2. Обробка виключень:
     • Коректна обробка помилок бази даних (наприклад, відсутність записів).
     • Повернення клієнту зрозумілих повідомлень про помилки.
     Програмна структура бізнес-логіки:
     1. Сервісний шар (Services):
     • Включає класи для кожної основної функції (наприклад, UserService, IoTDeviceService, LimitService).
     • Виконує бізнес-логіку: обробку даних, виклики репозиторіїв, обчислення тощо.
     2. Репозиторії (Repositories):
     • Робота з базою даних (CRUD-операції).
     • Інкапсуляція взаємодії з контекстом бази даних.
     3. Контролери (Controllers):
     • Здійснюють передачу даних між клієнтом і сервісним шаром.
     • Використовують сервіси для виконання бізнес-логіки.

     Функції адміністрування серверної частини забезпечують контроль і управління ключовими ресурсами системи, такими як користувачі, пристрої, ліміти й дані про споживання води. У контексті AquaTrack, це дозволяє адміністраторам виконувати такі завдання:
     Адміністрування користувачів:
     1. Перегляд списку користувачів:
     • Функціонал: Надання адміністраторам доступу до повного списку зареєстрованих користувачів.
     • Деталі реалізації: 
     o Виклик сервісу для отримання всіх записів із таблиці Users.
     o Фільтрація за ролями.
     2. Редагування профілів:
     • Функціонал: Зміна ролі користувача.
     • Деталі реалізації: 
     o Отримання користувача за ідентифікатором.
     o Застосування змін.
     o Збереження оновленого запису.
     3. Видалення користувачів:
     • Функціонал: Видалення облікових записів, які більше не потрібні.
     • Деталі реалізації: 
     o Видалення запису із таблиці Users.
     Адміністрування IoT-пристроїв:
     1. Перегляд списку пристроїв:
     • Функціонал: Відображення повного списку підключених пристроїв із деталями.
     • Деталі реалізації: 
     o Отримання записів із таблиці IoTDevices.
     o Фільтрація за статусом (активний, неактивний).
     2. Додавання нового пристрою:
     • Функціонал: Реєстрація нового IoT-пристрою в системі.
     • Деталі реалізації: 
     o Збереження номера, статусу.
     3. Видалення пристроїв:
     • Функціонал: Видалення пристроїв, які більше не використовуються.
     • Деталі реалізації: 
     o Видалення запису із таблиці IoTDevices.
     4. Моніторинг пристроїв:
     • Функціонал: Відстеження активності пристроїв.
     • Деталі реалізації: 
     o Виведення стану пристрою.
     o Сповіщення про проблеми.
     Адміністрування лімітів:
     1. Перегляд встановлених лімітів:
     • Функціонал: Перегляд поточних лімітів для водоспоживання.
     • Деталі реалізації: 
     o Отримання даних із таблиці Limits.
     o Відображення лімітів, прив’язаних до пристроїв або користувачів.
     2. Додавання нового ліміту:
     • Функціонал: Встановлення нового обмеження для водоспоживання.
     • Деталі реалізації: 
     o Валідація введених даних (значення ліміту, період дії тощо).
     o Збереження ліміту в базу даних.
     3. Оновлення існуючих лімітів:
     • Функціонал: Зміна поточних обмежень.
     • Деталі реалізації: 
     o Отримання ліміту за ідентифікатором.
     o Застосування нових параметрів.
     o Збереження зміненого запису.
     4. Видалення лімітів:
     • Функціонал: Видалення застарілих або непотрібних лімітів.
     • Деталі реалізації: 
     o Перевірка, чи є залежності (історія використання).
     o Видалення запису.
     Управління даними про використання води:
     1. Перегляд історії водоспоживання:
     • Функціонал: Надання доступу до історичних даних про використання води.
     • Деталі реалізації: 
     o Отримання даних із таблиці WaterUsages.
     o Фільтрація за пристроями або періодом.
     2. Генерація звітів:
     • Функціонал: Формування звітів по використанню води.
     • Деталі реалізації: 
     o Обробка даних із таблиці WaterUsages.
     o Генерація звітів у форматі PDF.
     Програмна структура для адміністрування:
     1. Контролери (Controllers):
     • Спеціалізовані контролери для користувачів, пристроїв, лімітів тощо.
     2. Сервісний шар (Services):
     • Класи: UserService, IoTDeviceService, LimitService, WaterUsageService.
     • Реалізація логіки адміністрування.
     3. Репозиторії (Repositories):
     • Класи: UserRepository, IoTDeviceRepository, LimitRepository, WaterUsageRepository.


     Реєстрація користувачів:
     Опис:
     Ця функція дозволяє створювати нових користувачів із перевіркою унікальності email, хешуванням пароля для безпеки та призначенням базової ролі «User».
     Кроки реалізації:
     1. Перевірка, чи існує користувач із таким же email:
     • Виконати пошук у базі даних за полем Email.
     • Якщо знайдено користувача, повернути відповідь із помилкою.
     2. Хешування пароля:
     • Використати бібліотеку для хешування паролів, наприклад, BCrypt.Net.
     • Хешований пароль зберігати в полі PasswordHash.
     3. Призначення ролі за замовчуванням:
     • Поле Role для нового користувача встановлюється у значення «User».
     Код методу в UserService:
        public void RegisterUser(User user)
        {
            // Перевірка, чи існує користувач із таким email
            if (_repository.GetAll().Any(u => u.Email == user.Email))
            {
                throw new Exception("Користувач із таким email вже існує.");
            }

            // Хешування пароля
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(user.PasswordHash);

            // Призначення ролі за замовчуванням
            user.Role = "User";

            // Додавання користувача до бази
            _repository.Add(user);
        }
     Код методу в UsersController:
        [HttpPost]
        [Route("register")]
        public IHttpActionResult Register(User user)
        {
            try
            {
                _service.RegisterUser(user);
                return Ok("Користувач успішно зареєстрований.");
            }
            catch (Exception ex)
            {
                return BadRequest(ex.Message);
            }
        }
     Авторизація користувачів:
     Опис:
     Функція авторизації забезпечує вхід користувача, перевіряючи введені дані (email і пароль) та порівнюючи хеш пароля.
     Кроки реалізації:
     1. Валідація введених даних:
     • Перевірка, чи не є email та пароль порожніми.
     2. Пошук користувача в базі даних за email:
     • Якщо користувача з таким email не знайдено, повернути помилку.
     3. Перевірка хешованого пароля:
     • Використати метод перевірки пароля (BCrypt.Verify).
     • Якщо пароль не збігається, повернути помилку авторизації.
     4. Успішна авторизація:
     • Повернути дані користувача (або токен, якщо використовується).
     Метод у UserService:
        public User Authenticate(string email, string password)
        {

            // Пошук користувача за email
            var user = _repository.GetAll().FirstOrDefault(u => u.Email == email);

            if (user == null)
            {
                throw new Exception("Користувача з таким email не знайдено.");
            }

            // Перевірка хешованого пароля
            if (!BCrypt.Net.BCrypt.Verify(password, user.PasswordHash))
            {
                throw new Exception("Невірний пароль.");
            }

            return user;
        } 
     Метод у UsersController:
        [HttpPost]
        [Route("login")]
        public IHttpActionResult Login(string email, string password)
        {

            try
            {
                var user = _service.Authenticate(email, password);
                return Ok(new
                {
                    Message = "Успішна авторизація",
                    UserId = user.UserId,
                    Username = user.Username,
                    Role = user.Role
                });
            }
            catch (Exception ex)
            {
                return Unauthorized(); // Неправильний логін або пароль
            }
        }
     
     Тестування:
     Реєстрація користувача:
     Відправити POST-запит до /api/users/register із даними користувача.

     Рисунок 3 – користувача успішно зареєстровано.
     
     Авторизація користувача:
     Відправити POST-запит до /api/users/login із правильними та неправильними даними.

Рисунок 4 – успішна авторизація.


Рисунок 5 – авторизація з неправильними даними.
     
     Для реалізації управління IoT-пристроями в рамках системи, а також обробки даних, отриманих від цих пристроїв, необхідно виконати наступні дії:
     Додавання нового пристрою:
     Для реєстрації IoT-пристроїв уже підготовлено метод RegisterDevice в контролері IoTDevicesController. 
     Реалізація API для додавання пристрою:
     Контролер: метод RegisterDevice приймає модель пристрою (IoTDevice) і додає її через сервіс. Реалізація вже підготовлена:
[HttpPost]
[Route("register")]
public IHttpActionResult RegisterDevice(IoTDevice device)
{
    _service.AddDevice(device);
    return Ok(device);
}
     Модель пристрою: модель IoTDevice містить такі властивості:
     • DeviceId — Унікальний ідентифікатор.
     • DeviceType — Тип пристрою.
     • Status — Статус (активний/неактивний).
     • Зв’язок із таблицею Limits.
     Логіка в сервісі: у методі AddDevice викликається відповідний метод репозиторію:
public void AddDevice(IoTDevice device)
{
    _repository.Add(device);
}

     Код сервісу WaterUsageService виглядає добре структурованим для роботи з історією використання води та додаванням нових записів. Розширимо і уточнимо його функціональність для повної реалізації збору даних від IoT-пристроїв:
     Перевірка валідності даних пристрою:
     Перед збереженням запису використання води переконаємося, що пристрій із відповідним DeviceId існує. Для цього можна додати перевірку у метод AddUsageRecord.
     Оновлений метод AddUsageRecord:
        public void AddUsageRecord(WaterUsage usage, IoTDeviceService deviceService)
        {
            // Перевірка пристрою
            var device = deviceService.GetDeviceById(usage.DeviceId);
            if (device == null)
                throw new ArgumentException($"Device with ID {usage.DeviceId} not found.");

            // Перевірка дублювання запису
            var existingRecord = _repository.GetAll()
                .FirstOrDefault(w => w.DeviceId == usage.DeviceId && w.Timestamp == usage.Timestamp);

            if (existingRecord != null)
                throw new ArgumentException("Duplicate record for the same device and timestamp.");

            // Валідація обсягу
            if (usage.UsageValue < 0)
                throw new ArgumentException("Usage value cannot be negative.");

            // Додавання запису
            _repository.Add(usage);
        } 
     Метод для збору даних від пристроїв:
     У контролері IoTDevicesController можна створити API для збору даних, який буде викликати цей метод. У сервісі WaterUsageService не потрібно суттєвих змін, оскільки вже є метод AddUsageRecord.
     Оновлений API у контролері
     Контролер:
        [HttpPost]
        [Route("collect-data")]
        public IHttpActionResult CollectData(WaterUsage data)
        {
            try
            {
                _waterUsageService.AddUsageRecord(data, _service);
                return Ok("Data collected successfully.");
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        }
     Розглянемо реалізацію функціоналу управління лімітами водоспоживання поетапно.
     Створення лімітів:
     Логіка: ліміт має містити максимальний обсяг використаної води (LimitValue), період дії (StartDate, EndDate) і бути прив’язаним до конкретного IoT-пристрою та користувача.
     Код уже готовий:
     • LimitService для роботи з лімітами.
     • LimitsController для API-запитів створення, оновлення та видалення лімітів.
     Тестування:
     Swagger: Використаємо маршрут POST /api/limits/create, щоб створити тестовий ліміт.
     При введенні некоректних даних бачимо відповідні помилки:

Рисунок 6 – Введення некоректної дати.

Рисунок 7 – Введення некоректного зачення.

     Перевірка перевищення лімітів:
     Логіка: розрахунок поточного обсягу використаної води:
     Додати всі записи з таблиці WaterUsage, які відповідають пристрою (DeviceId) та входять у період дії ліміту (StartDate, EndDate).
     Порівняння з лімітом: якщо сума перевищує LimitValue, то ліміт порушено.
     Код для перевірки. Додамо метод до LimitService:
        public bool IsLimitExceeded(int limitId)
        {
            var limit = _repository.GetById(limitId);
            if (limit == null) throw new ArgumentException("Limit not found.");

            var totalUsage = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Sum(w => w.UsageValue);

            return totalUsage > limit.LimitValue;
        } 
     API для перевірки:
     Додамо новий маршрут до LimitsController:
        [HttpGet]
        [Route("check-exceeded/{limitId}")]
        public IHttpActionResult CheckLimitExceeded(int limitId)
        {
            try
            {
                var isExceeded = _service.IsLimitExceeded(limitId);
                return Ok(new { LimitExceeded = isExceeded });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Статистика по лімітах:
     Логіка: визначити, наскільки споживання наближається до ліміту у відсотках.
     Додамо метод до LimitService:
        public decimal GetLimitProgress(int limitId)
        {
            var limit = _repository.GetById(limitId);
            if (limit == null) throw new ArgumentException("Limit not found.");

            var totalUsage = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Sum(w => w.UsageValue);

            return (totalUsage / limit.LimitValue) * 100;
        } 
     API для статистики:
     Додамо новий маршрут до LimitsController:

        [HttpGet]
        [Route("progress/{limitId}")]
        public IHttpActionResult GetLimitProgress(int limitId)
        {
            try
            {
                var progress = _service.GetLimitProgress(limitId);
                return Ok(new { Progress = progress });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Прийом даних про обсяг використаної води від IoT-пристроїв:
     У WaterUsageService використовуємо метод AddUsageRecord, який перевіряє пристрій, дублювання запису та валідує значення споживаної води. Це важлива частина процесу, яка гарантує правильність введених даних.
     Візуалізація статистики для клієнта:
     Щоб забезпечити візуалізацію даних для клієнта, можна реалізувати методи в WaterUsageController, які надають агреговану інформацію:
        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Цей метод поверне середнє споживання води за вказаний період. Для подальшої візуалізації на клієнтській стороні.
     Оновлення методу GetCurrentUsage:
     Щоб зробити метод більш гнучким і додати можливість отримувати поточні дані не тільки для останнього запису, можна додати параметри для отримання поточного значення водоспоживання для певного пристрою за певний період:
        public WaterUsage GetCurrentUsage(int deviceId)
        {
            return _repository
                .GetAll()
                .Where(w => w.DeviceId == deviceId)
                .OrderByDescending(w => w.Timestamp)
                .FirstOrDefault();
        } 
     Цей метод дозволить отримувати актуальні дані для конкретного пристрою.
     Метод для визначення середнього використання за період:
     Додамо новий метод до WaterUsageService для обчислення середнього використання води за вказаний період, наприклад, день, місяць чи рік.
     Код:
        public decimal GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            var usageRecords = _repository
                .GetAll()
                .Where(w => w.DeviceId == deviceId && w.Timestamp >= startDate && w.Timestamp <= endDate)
                .ToList();

            if (!usageRecords.Any())
                throw new ArgumentException("No usage records found for the specified period.");

            // Підрахунок загального використання і середнього
            var totalUsage = usageRecords.Sum(w => w.UsageValue);
            var daysCount = (endDate - startDate).Days;

            return totalUsage / daysCount;
        } 
     Цей метод обчислює середнє використання води для певного пристрою між вказаними датами. Він підсумовує всі записи і ділить на кількість днів у вказаному періоді.
     Контролер для роботи з новими методами:
     У контролері WaterUsageController.cs потрібно додати нові маршрути для цих методів.
     Для отримання поточного використання для конкретного пристрою:
[HttpGet]
[Route("current/{deviceId}")]
public IHttpActionResult GetCurrentUsage(int deviceId)
{
var currentUsage = _service.GetCurrentUsage(deviceId);
if (currentUsage == null)
return NotFound();

return Ok(currentUsage);
        } 
     Для отримання середнього використання за період:
        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Тепер, при виклику наступних маршрутів, можна отримувати відповідні дані:
     • GET api/water-usage/current/{deviceId} – для поточного використання для конкретного пристрою.
     • GET api/water-usage/average-usage?deviceId={deviceId}&startDate={startDate}&endDate={endDate} – для отримання середнього використання води для конкретного пристрою за період.
     Це дозволить клієнту легко отримувати актуальні дані і статистику по використанню води для певних пристроїв.
     
     Для впровадження функціоналу «Перегляд списку користувачів» в адміністративному інтерфейсі, вже маємо готові основні компоненти. Опишемо кроки реалізації:
     Контролер UsersController:
     Метод GetUsers вже реалізований для отримання списку всіх користувачів із перевіркою ролі адміністратора. Цей метод відповідає за валідацію ролі поточного користувача, виклик методу GetAllUsers сервісу UserService.
     Фільтрація за ролями:
     Для фільтрування користувачів за ролями (наприклад, «User», «Admin»), додамо можливість передавати параметри в API:
     Розширений метод з фільтром:

        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetUsers(string role = null)
        {
            var currentUserRole = "Admin"; // Перевірка ролі
            if (currentUserRole != "Admin")
            {
                return Content(HttpStatusCode.Forbidden, "Доступ дозволений тільки адміністраторам.");
            }

            var users = _service.GetAllUsers();
            if (!string.IsNullOrEmpty(role))
            {
                users = users.Where(u => u.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
            }

            return Ok(users);
        } 
     Сервіс UserService:
     Сервіс уже має метод GetAllUsers, який повертає список користувачів та додамо фільтрацію за роллю безпосередньо в цьому методі:
        public IEnumerable<User> GetAllUsers(string role = null)
        {
            var users = _repository.GetAll();
            if (!string.IsNullOrEmpty(role))
            {
                users = users.Where(u => u.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
            }
            return users;
        }
     Цей функціонал забезпечить адміністраторам доступ до списку користувачів із можливістю фільтрації та подальшого управління.
     
     Для реалізації функціоналу «Редагування профілів: Зміна ролі користувача», необхідно виконати наступні кроки:
     Додамо метод у UsersController:
     Метод повинен приймати ID користувача і нову роль, яку потрібно призначити.
     Метод для зміни ролі:
        [HttpPut]
        [Route("update-role")]
        public IHttpActionResult UpdateRole(int userId, string newRole)
        {
            try
            {
                var user = _service.GetUserById(userId);
                if (user == null)
                {
                    return NotFound(); // Користувача не знайдено
                }

                // Перевірка нової ролі
                var validRoles = new List<string> { "User", "Admin", "Moderator" }; // Додайте ваші ролі
                if (!validRoles.Contains(newRole))
                {
                    return BadRequest("Невірна роль.");
                }

                // Оновлення ролі
                user.Role = newRole;
                _service.UpdateUser(user);

                return Ok($"Роль користувача з ID {userId} успішно змінено на {newRole}.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Помилка при оновленні ролі: {ex.Message}");
            }
        } 
     Маршрут:
     PUT /api/users/update-role
     Body: { "userId": 1, "newRole": "Admin" }
     Додамо метод у UserService:
     Використаємо наявний метод UpdateUser, щоб змінювати роль користувача.
     Метод у сервісі:
        public void UpdateUserRole(int userId, string newRole)
        {
            var user = GetUserById(userId);
            if (user == null)
            {
                throw new Exception("Користувача не знайдено.");
            }

            user.Role = newRole;
            UpdateUser(user);
        } 
     Цей функціонал забезпечує базову можливість адміністрування користувачів, дозволяючи змінювати їх ролі.
     
     Для реалізації функціоналу «Видалення користувачів», необхідно додати методи до UsersController, UserService, та інтегрувати цей функціонал в WinForms.
     Додамо метод у UsersController:
     Код:
        [HttpDelete]
        [Route("delete/{id}")]
        public IHttpActionResult DeleteUser(int id)
        {
            var currentUserRole = "Admin"; // Замінити на реальну перевірку ролі

            if (currentUserRole != "Admin")
            {
                return Content(HttpStatusCode.Forbidden, "Доступ дозволений тільки адміністраторам.");
            }

            try
            {
                var user = _service.GetUserById(id);
                if (user == null)
                {
                    return NotFound();
                }

                _service.DeleteUser(id);
                return Ok($"Користувача з ID {id} успішно видалено.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Помилка видалення: {ex.Message}");
            }
        }
     
     Додамо метод у UserService:
        public void DeleteUser(int id)
        {
            var user = _repository.GetById(id);
            if (user == null)
            {
                throw new Exception("Користувача з таким ID не знайдено.");
            }

            _repository.Delete(id);
        } 
     Цей функціонал забезпечує безпечне та ефективне видалення облікових записів, які більше не потрібні в системі.
     
     Для реалізації функціоналу перегляду списку IoT-пристроїв із фільтрацією за статусом, потрібно буде додати API маршрут для фільтрації пристроїв за статусом.
     В контролері IoTDevicesController додамо новий метод для отримання пристроїв із фільтрацією за статусом:
        [HttpGet]
        [Route("list-by-status")]
        public IHttpActionResult GetDevicesByStatus(string status)
        {
            var devices = _service.GetAllDevices()
                                  .Where(d => d.Status.Equals(status, StringComparison.OrdinalIgnoreCase))
                                  .ToList();

            if (!devices.Any())
                return NotFound();

            return Ok(devices);
        } 
     Цей метод прийматиме параметр status і фільтруватиме пристрої за статусом.
     
     Для реалізації функціоналу видалення IoT-пристроїв, які більше не використовуються, потрібно додати необхідний інтерфейс на клієнтській стороні та забезпечити інтеграцію з існуючим серверним методом.
     Серверна частина:
     Метод DeleteDevice у контролері IoTDevicesController вже реалізований.
     Маршрут для видалення: DELETE /api/iot-devices/delete/{deviceId}.
     Цей метод перевіряє існування пристрою за deviceId і видаляє його з бази даних.
     Результат:
     1. Користувач вибирає пристрій зі списку і натискає кнопку «Видалити».
     2. Система запитує підтвердження.
     3. Після підтвердження відправляється запит DELETE /api/iot-devices/delete/{deviceId} до сервера.
     4. Пристрій видаляється із бази даних.
     5. Список пристроїв оновлюється у клієнтському інтерфейсі.
     
     Для реалізації функціоналу моніторингу активності IoT-пристроїв (відстеження статусу активності: активний чи неактивний) потрібно забезпечити:
1. Виведення стану пристрою на клієнтській стороні.
2. Можливість періодичного оновлення статусу (опціонально, для динамічного моніторингу).
     Серверна частина:
     У контролері IoTDevicesController вже є метод GetDevices, який повертає всі пристрої з їх статусами. Статус пристрою зберігається у полі Status.
     Цей метод можна використовувати для отримання актуального статусу пристроїв.
     
     Для реалізації функціоналу перегляду встановлених лімітів водоспоживання, можна використовувати вже наявну структуру коду. 
     Серверна частина:
     У контролері LimitsController вже є методи для роботи з лімітами, зокрема для їх створення, оновлення, видалення, а також перевірки перевищення ліміту і прогресу ліміту.
     Додамо метод для отримання всіх лімітів:
        [HttpGet]
        [Route("list")]
        public IHttpActionResult GetLimits()
        {
            var limits = _service.GetAllLimits();
            return Ok(limits);
        } 
     Цей метод повертає список усіх лімітів, які є в базі даних. 
     Додаткові функції:
     Перевищення ліміту: додано можливість перевірки, чи було перевищено ліміт для конкретного пристрою. Це можна зробити за допомогою методу CheckLimitExceeded в контролері, який буде повертати інформацію, чи перевищено ліміт:
        [HttpGet]
        [Route("check-exceeded/{limitId}")]
        public IHttpActionResult CheckLimitExceeded(int limitId)
        {
            try
            {
                var isExceeded = _service.IsLimitExceeded(limitId);
                return Ok(new { LimitExceeded = isExceeded });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Прогрес ліміту: для виведення прогресу використаємо метод GetLimitProgress, який обчислює процент виконання ліміту:
        [HttpGet]
        [Route("progress/{limitId}")]
        public IHttpActionResult GetLimitProgress(int limitId)
        {
            try
            {
                var progress = _service.GetLimitProgress(limitId);
                return Ok(new { Progress = progress });
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
            catch
            {
                return InternalServerError();
            }
        } 
     Це рішення дозволить зручно моніторити та управляти лімітами споживання води в системі AquaTrack.
     
     Щоб реалізувати додавання нового ліміту для водоспоживання з валідацією введених даних, можна розглянути наступні кроки:
     Валідація введених даних: перед тим, як додавати ліміт до бази даних, потрібно провести перевірку правильності введених даних. Валідація повинна охоплювати:
• Перевірка, що значення ліміту (LimitValue) є додатнім числом.
• Перевірка, що дата початку (StartDate) менша за дату закінчення (EndDate).
• Перевірка на наявність обмежень для користувача чи пристрою на той самий період.
     Реалізація в контролері:
     У контролері LimitsController можна додати метод для створення ліміту, враховуючи валідацію:
        [HttpPost]
        [Route("create")]
        public IHttpActionResult CreateLimit(Limit limit)
        {
            // Валідація
            if (limit.LimitValue <= 0)
            {
                return BadRequest("Значення ліміту повинно бути більшим за 0.");
            }

            if (limit.StartDate >= limit.EndDate)
            {
                return BadRequest("Дата початку повинна бути менша за дату закінчення.");
            }

            var existingLimit = _service.GetAllLimits().FirstOrDefault(l =>
                (l.UserId == limit.UserId || l.DeviceId == limit.DeviceId) &&
                (l.StartDate < limit.EndDate && l.EndDate > limit.StartDate));  // Перевірка на перекриття ліміту
            if (existingLimit != null)
            {
                return BadRequest("Існує ліміт, який перекривається з цим.");
            }

            // Збереження ліміту в базу даних
            _service.CreateLimit(limit);
            return Ok(limit);
        } 
     Валідація та збереження у сервісному класі:
     У класі LimitService для створення ліміту додамо додаткові перевірки:

        public void CreateLimit(Limit limit)
        {
            // Перевірка на наявність періодів, що перекриваються
            var existingLimit = _repository.GetAll().FirstOrDefault(l =>
                (l.UserId == limit.UserId || l.DeviceId == limit.DeviceId) &&
                (l.StartDate < limit.EndDate && l.EndDate > limit.StartDate));

            if (existingLimit != null)
            {
                throw new ArgumentException("Існує ліміт, який перекривається з цим.");
            }

            _repository.Add(limit);
        } 
     Оновлення репозиторію для додавання:
     У класі LimitRepository реалізація методу Add виглядатиме стандартно:
        public void Add(Limit entity)
        {
            _context.Limits.Add(entity);
            _context.SaveChanges();
        } 
     Цей процес гарантує, що дані будуть коректно оброблені перед тим, як зберігатися в базі даних.
     
     Для реалізації функціоналу «Оновлення існуючих лімітів» у системі, вже маємо основні класи та методи, які допоможуть здійснити оновлення ліміту. 
     Отримання ліміту за ідентифікатором:
     Отримання ліміту виконується в методі GetLimitById сервісу LimitService:
        public Limit GetLimitById(int id)
        {
            return _repository.GetById(id);
        } 
     Застосування нових параметрів:
     Прийом оновлених параметрів ліміту, таких як LimitValue, StartDate, EndDate, і застосування їх до поточного запису.
     В контролері (LimitsController) приймаємо об'єкт updatedLimit, який містить нові значення, і оновлюємо ліміт через сервіс:

        [HttpPut]
        [Route("update/{limitId}")]
        public IHttpActionResult UpdateLimit(int limitId, Limit updatedLimit)
        {
            var limit = _service.GetLimitById(limitId);
            if (limit == null) return NotFound();

            // Перевірка на коректність дат
            if (updatedLimit.StartDate > updatedLimit.EndDate)
            {
                return BadRequest("Дата завершення повинна бути після дати початку.");
            }

            updatedLimit.LimitId = limitId; // Встановлюємо ідентифікатор ліміту
            _service.UpdateLimit(updatedLimit); // Оновлення ліміту
            return Ok(updatedLimit); // Повертаємо оновлений ліміт
        } 
     Збереження зміненого запису:
     Збереження оновленого ліміту в базу даних. Це відбувається в методі Update класу LimitRepository, який викликається з сервісу:
        public void Update(Limit entity)
        {
            _context.Entry(entity).State = System.Data.Entity.EntityState.Modified;
            _context.SaveChanges();
        } 
     Пояснення кроків:
• Отримання ліміту за ідентифікатором: знаходимо існуючий ліміт у базі за допомогою ідентифікатора, щоб перевірити його наявність.
• Застосування нових параметрів: після отримання ліміту можемо змінювати будь-які поля (наприклад, нові значення ліміту, дати) перед збереженням у базу.
• Збереження змін: внесені зміни записуються назад у базу даних, використовуючи метод Update.
     Таким чином, маємо повністю функціональну систему для оновлення лімітів, яка забезпечує валідацію та збереження змін.
     Для реалізації функціоналу видалення ліміту з перевіркою на наявність залежностей (історії використання води)  потрібно додати логіку перевірки перед видаленням ліміту. Якщо ліміт має записи в історії використання води, то не можна його видаляти, або, принаймні, потрібно повідомити користувача про це.
     Модифікуємо метод видалення в LimitService.cs та LimitsController.cs.
     Додавання перевірки в LimitService.cs:
     У класі LimitService потрібно перевіряти, чи є історія використання води для певного ліміту перед його видаленням:
        public void DeleteLimit(int id)
        {
            var limit = _repository.GetById(id);
            if (limit == null) throw new ArgumentException("Ліміт не знайдено.");

            // Перевірка на наявність історії використання води
            var usageHistory = _waterUsageRepository.GetAll()
                .Where(w => w.DeviceId == limit.DeviceId &&
                            w.Timestamp >= limit.StartDate &&
                            w.Timestamp <= limit.EndDate)
                .Any();

            if (usageHistory)
            {
                throw new InvalidOperationException("Неможливо видалити ліміт, оскільки з ним пов'язана історія використання води.");
            }

            _repository.Delete(id);  // Видалення ліміту
        } 
     Оновлення контролера LimitsController.cs:
     У контролері потрібно обробити виняток, який може виникнути під час спроби видалення ліміту:
        [HttpDelete]
        [Route("delete/{limitId}")]
        public IHttpActionResult DeleteLimit(int limitId)
        {
            try
            {
                var limit = _service.GetLimitById(limitId);
                if (limit == null) return NotFound();

                _service.DeleteLimit(limitId);  // Викликається метод видалення ліміту
                return Ok();
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);  // Обробка помилки, якщо ліміт не можна видалити
            }
            catch (Exception ex)
            {
                return InternalServerError(ex);  // Інші помилки
            }
        } 
     Пояснення:
1. Перевірка на наявність історії використання: перед видаленням ліміту в методі DeleteLimit перевіряється, чи існує історія використання води, яка відповідає цьому ліміту. Якщо такі записи є, то видалення не проводиться, і викидається виключення InvalidOperationException.
2. Обробка помилки у контролері: Якщо спроба видалення ліміту зазнає помилки, наприклад, через наявність історії використання, контролер повертає клієнту помилку з відповідним повідомленням.
     Таким чином, можемо захистити систему від видалення лімітів, що мають історію використання, і надаємо користувачеві корисне повідомлення про помилку.
     
     Для реалізації функціоналу перегляду історії водоспоживання з можливістю фільтрації за пристроями або періодом, потрібно додати параметри для фільтрації в методи контролера та сервісу.
     Оновлення методу GetUsageHistory в WaterUsageService.cs:
     Додамо можливість фільтрації даних за періодом і пристроєм:
        public IEnumerable<WaterUsage> GetUsageHistory(int? deviceId = null, DateTime? startDate = null, DateTime? endDate = null)
        {
            var query = _repository.GetAll().AsQueryable();

            if (deviceId.HasValue)
            {
                query = query.Where(w => w.DeviceId == deviceId.Value);
            }

            if (startDate.HasValue)
            {
                query = query.Where(w => w.Timestamp >= startDate.Value);
            }

            if (endDate.HasValue)
            {
                query = query.Where(w => w.Timestamp <= endDate.Value);
            }

            return query.OrderByDescending(w => w.Timestamp).ToList();
        } 
     Оновлення методу GetHistory в WaterUsageController.cs:
     Тепер додамо параметри для фільтрації в контролер. Можемо передавати параметри, такі як deviceId, startDate, і endDate у запиті:
        [HttpGet]
        [Route("history")]
        public IHttpActionResult GetHistory(int? deviceId = null, DateTime? startDate = null, DateTime? endDate = null)
        {
            try
            {
                var history = _service.GetUsageHistory(deviceId, startDate, endDate);
                return Ok(history);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Оновлення методу GetAverageUsage для обробки періоду:
     Ми вже маємо метод для обчислення середнього використання води за період, але потрібно переконатись, що він працює коректно із зазначенням дат:
        [HttpGet]
        [Route("average-usage")]
        public IHttpActionResult GetAverageUsage(int deviceId, DateTime startDate, DateTime endDate)
        {
            try
            {
                var averageUsage = _service.GetAverageUsage(deviceId, startDate, endDate);
                return Ok(averageUsage);
            }
            catch (ArgumentException ex)
            {
                return BadRequest(ex.Message);
            }
        } 
     Пояснення:
1. Фільтрація за пристроєм і періодом: метод GetUsageHistory дозволяє фільтрувати записи за пристроєм (deviceId), датою початку (startDate) та датою кінця (endDate). Параметри можуть бути необов'язковими, тому їх можна передавати через URL-запит.
2. Фільтрація в контролері: контролер приймає параметри через запит, що дозволяє фільтрувати дані на сервері перед тим, як повернути їх користувачу.
3. Обчислення середнього використання: в GetAverageUsage можна отримати середнє значення використання води за заданий період для конкретного пристрою.
     Це забезпечить функціональність перегляду історії водоспоживання з фільтрацією за пристроєм і датами, а також можливість обчислення середнього використання води за конкретний період.

     Посилання на відеозапис:https://www.youtube.com/watch?v=faU0lbkj12E
     Висновок:
     У рамках лабораторної роботи було розроблено бізнес-логіку та функції адміністрування серверної частини системи AquaTrack. Реалізовано функціонал для управління даними, включаючи обробку, валідацію та аналіз інформації про використання води. Забезпечено безпечну взаємодію з базою даних через RESTful API, використовуючи технології Entity Framework та ASP.NET Web API.
     Створені UML-діаграми діяльності та взаємодії дозволили формалізувати процеси системи. Розроблена серверна частина є гнучкою, масштабованою та готовою до інтеграції з новими функціональними вимогами.
    
